" Toggle paste insert mode.
set pastetoggle=<F2>

" More reachable end and start line.
noremap H ^
noremap L $

" Don't use the manual.
noremap K k

" Auto reload .vimrc on write.
autocmd! bufwritepost .vimrc source %

" Enable mouse usage in all modes.
set mouse=a

" Make Backspace and Delete work as expected.
set bs=2

let mapleader = ','

" Quicksave command
noremap <C-Q> :update<CR>
vnoremap <C-Q> <C-C>:update<CR>
inoremap <C-Q> <C-O>:update<CR>

" Change swap dir ('//' for absolute paths).
set directory=~/.vimswap//

" 80 char limit.
set textwidth=80

" Keep search pattern at the center of the screen.
nnoremap <silent> n nzz
nnoremap <silent> N Nzz

" I can type :help on my own, thanks.
inoremap <F1> <nop>
nnoremap <F1> <nop>
vnoremap <F1> <nop>

" Disable vi compatibility.
set nocompatible
" Confirm to save file instead of failing a command.
set confirm
set undolevels=666
" Doesn't automaticaly break the line. Use gq to rewrap.
set formatoptions-=t
" Anybody who uses anything else should be shot I'm afraid to say.
set encoding=utf-8

" Search options:
set hlsearch " Highlight results.
set incsearch " Don't wait for me to hit enter to search.
set ignorecase

" Indentation options:
set smartindent
set expandtab " Replace <tab> with spaces.
set smarttab " Backspace spaces as if they were tabs.
set tabstop=2
set softtabstop=2
set shiftwidth=2

" Text options:
set scrolloff=3 " Keep 3 lines at the top or bottom of the screen
"set number " Line numbers.
set ruler " Show line and column in the status bar.

" Always show tab line.
set showtabline=2

" Status line:
set statusline=%f " relative file path
set statusline+=%= " left-right separator
set statusline+=\ %l:%c " cursor line:column
set statusline+=\ %P " percent through file

" Use 1 space when joining sentences.
set nojoinspaces

" Colors.
syntax on
colorscheme default

" Override Vim's autodetection.
if $COLORTERM == 'gnome-terminal'
  set t_Co=256
endif

" Reselect visual block after indent/outdent.
vnoremap < <gv
vnoremap > >gv

" Use C+J & C+K to scroll command history.
cnoremap <C-J> <t_kd>
cnoremap <C-K> <t_ku>
cnoremap <C-A> <Home>
cnoremap <C-E> <End>

" Map Q to repeat last recorded command.
map Q @@

" Tell vim to remember certain things when we exit
"  '10  :  marks will be remembered for up to 10 previously edited files
"  "100 :  will save up to 100 lines for each register
"  :20  :  up to 20 lines of command-line history will be remembered
"  %    :  saves and restores the buffer list
"  n... :  where to save the viminfo files
set viminfo='10,\"100,:20,%,n~/.viminfo

" Navigation windows
nnoremap <C-J> <C-W><C-J>
nnoremap <C-K> <C-W><C-K>
nnoremap <C-L> <C-W><C-L>
nnoremap <C-H> <C-W><C-H>

" Use tab to complete. If only whitespace, use actual tab.
:inoremap <Tab> <C-R>=TabOrComplete()<CR>

" Go to tab by number.
noremap <Leader>1 1gt
noremap <Leader>2 2gt
noremap <Leader>3 3gt
noremap <Leader>4 4gt
noremap <Leader>5 5gt
noremap <Leader>6 6gt
noremap <Leader>7 7gt
noremap <Leader>8 8gt
noremap <Leader>9 9gt
noremap <Leader>0 :tablast<CR>
map <Leader>a <ESC>:tabprevious<CR>
map <Leader>s <ESC>:tabnext<CR>

" Nerd tree. Toggle it with Ctrl+N.
map <C-n> :NERDTreeToggle<CR>

" Pathogen.
execute pathogen#infect()

" What to ignore in CtrlP.
let g:ctrlp_custom_ignore = 'node_modules\|DS_Store\|git\|build'

" Toggle previous file with `,,`.
nnoremap ,, <c-^>

" Execute current file.
map ,e :call ExecuteFile(expand("%"))<cr>

autocmd Syntax c,java,cpp,cs call CLikeMode()

autocmd FileType python set ts=4 sw=4 sts=4

" Restore cursor on reopening.
function! ResCur()
  if line("'\"") <= line("$")
    normal! g`"
    return 1
  endif
endfunction

augroup resCur
  autocmd!
  autocmd BufWinEnter * call ResCur()
augroup END

" Highlight trailing spaces in annoying red.
highlight ExtraWhitespace ctermbg=1 guibg=red
match ExtraWhitespace /\s\+$/
autocmd BufWinEnter * match ExtraWhitespace /\s\+$/
autocmd InsertEnter * match ExtraWhitespace /\s\+\%#\@<!$/
autocmd InsertLeave * match ExtraWhitespace /\s\+$/
autocmd BufWinLeave * call clearmatches()

" Git Gutter highlights.
highlight GitGutterAdd ctermbg=235 ctermfg=Green
highlight GitGutterChange ctermbg=235 ctermfg=Yellow
highlight GitGutterDelete ctermbg=235 ctermfg=Red
highlight GitGutterChangeDelete ctermbg=235 ctermfg=Yellow
highlight SignColumn ctermbg=235 ctermfg=White

" Line numbers columns.
highlight LineNr ctermbg=233 ctermfg=240

" Splitting colors.
highlight VertSplit ctermbg=240 ctermfg=Black
highlight StatusLine ctermbg=Black ctermfg=242
highlight StatusLineNC ctermbg=231 ctermfg=235

" Tab colors.
highlight TabLineFill ctermbg=235 ctermfg=235
highlight TabLine ctermbg=238 ctermfg=White cterm=NONE
highlight TabLineSel ctermbg=Black ctermfg=White

" Show lines over 80 chars as errors.
au BufWinEnter * let w:m1=matchadd('ErrorMsg', '\%81v.', -1)

" Toggle show numbers.
nmap <C-M> :set invnumber<CR>

" Toggle GitGutter.
nmap <C-G> :GitGutterToggle<CR>
" Turn off GitGutter by default.
let g:gitgutter_enabled = 0

" Functions --------------------------------------------------------------------
function! CLikeMode()
  if !exists("b:clikeState") || b:clikeState == "off"
    let b:clikeState = "on"
    set autoindent
    set cindent
    if !exists("b:matchState") || b:matchState == "off"
      call ToggleCompleteMatching()
    endif
  else
    let b:clikeState = "off"
    set noautoindent
    set nocindent
    if exists("b:matchState") && b:matchState == "on"
      call ToggleCompleteMatching()
    endif
  endif
endf

function! ToggleCompleteMatching()
  if !exists("b:matchState") || b:matchState == "off"
    let b:matchState = "on"
    inoremap ( ()<Esc>i
    inoremap [ []<Esc>i
    inoremap ) <c-r>=ClosePair(')')<CR>
    inoremap ] <c-r>=ClosePair(']')<CR>
    inoremap " <c-r>=QuoteDelim('"')<CR>
    inoremap ' <c-r>=QuoteDelim("'")<CR>
  else
    let b:matchState = "off"
    iunmap (
    iunmap [
    iunmap )
    iunmap ]
    iunmap "
    iunmap '
  endif
endf

function! ClosePair(char)
  if getline('.')[col('.') - 1] == a:char
    return "\<Right>"
  else
    return a:char
  endif
endf

function! CloseBracket()
  if match(getline(line('.') + 1), '\s*}') < 0
    return "\<CR>}"
  else
    return "\<Esc>j0f}o"
  endif
endf

function! QuoteDelim(char)
   let line = getline('.')
   let col = col('.')
   if line[col - 2] == "\\"
     "Inserting a quoted quotation mark into the string
     return a:char
   elseif line[col - 1] == a:char
     "Escaping out of the string
     return "\<Right>"
   else
     "Starting a string
     return a:char.a:char."\<Esc>i"
   endif
endf

function! TabOrComplete()
  if col('.') > 1 && strpart(getline('.'), col('.')-2, 3) =~ '^\w'
    return "\<C-N>"
  else
    return "\<Tab>"
  endif
endf

" Execute file if know how. Note that the file is saved before executing.
function! ExecuteFile(filename)
  :w
  :silent !clear
  if match(a:filename, '\.coffee$') != -1
    exec ":!coffee " . a:filename
  elseif match(a:filename, '\.js$') != -1
    exec ":!node " . a:filename
  elseif match(a:filename, '\.py$') != -1
    exec ":!python " . a:filename
  elseif match(a:filename, '\.sh$') != -1
    exec ":!bash " . a:filename
  elseif match(a:filename, '\.go$') != -1
    exec ":!go run " . a:filename
  else
    exec ":!echo \"Don't know how to execute: \"" . a:filename
  end
endf

" Function calls.

call ToggleCompleteMatching()
